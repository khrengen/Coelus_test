# ЗАДАЧА ЗАМОЩЕНИЯ

## 1. Ход рассуждений
Первая идея - метод перебора, такой алгоритм почти всегда оказывается неоптимальным. Ограничения задачи, такие как фиксированный размер стола, наличия только двух форм полимино, наталкивают на мысль, что задача может решаться за полиномиальное время. Следующая идея - применить жадный алгоритм. Жадный выбор - добавление, которое минимально увеличит периметр свободного стола. Это логично - чем больше соприкасаются полимино и чем меньше отдельных высупов, тем меньше периметр свободного стола, а значит, больше места для добавления следующего полимино. Однако применить его не удалось - невозможно определить порядок выбора при одинаково меняющих периметр вставках. В таких ситуациях можно было бы продолжать перебором, что в среднем ускорило бы алгоритм достаточно нелпохо, но только в случае, если известно, что замощение существует. В этом главная проблема - доказать, что замощение не существует можно только полным перебором, так как задача NP-сложная(скорее всего), что не оставляет другого выбора.

## 2. Идея алгоритма и реализации
Вставляем полимино пока это возможно. Когда нет - переставляем предыдущий полимино, и так далее. При решении перебором необходимо всевозможно уменьшать количество вызовов и выделение памяти. Стол и полимино удобно хранить в виде матриц соответствующих размерностей, таким образом можно сразу использовать операции линейной алгебры.

## 3. Оценка по времени и памяти

Память: Размер стола + сумма размеров всех полимино (т.е. линейно относительно количества всех полимино)

Время: (4*M*N)^(K), где M*N - размер стола, K-суммарное количество полимино. Экспоненциальная сложность.

## 4. Инструкции к запуску
установка numpy: pip install numpy
запуск: python solution.py
входные данные размещать в файле input.txt в виде:
M1 M2 - размер прямоугольника стола
n1 - количество опорных прямоугольных полимино
n_pwr - мощность iого опорного полимино
с1 с2 - размер прямоугольного полимино
...
аналогично для L-полимино 

